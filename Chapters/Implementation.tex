% !tex root = ../Thesis.tex

This chapter describes the design, module implemetation and final implemetations
of the pitch correction system. The implementation code was written in Octave, a
free and open source alternative to Matlab. Some important, short code-snips are
shown and explaind to give deeper insight into the details of the implementation.

Since one of the goals of this report is to compare the performance of the pitch
corrector when using different modules, the evaluation metrics used are described
first. Theses metrics are described first to reflect the fact that the metrics
were designed before the structure and submodules were implemented in an effort to
minimise biased results. Once these metrics are well understood, the desing and
implementation of the pitch corrector and its submodules are described.

\section{Evaluation Metrics Design}

The goal of using metrics is to give a meaningful quantitative way of measuring
the success of the pitch corrector. It provides way to compare the performance of
different sub modules and choose the configuration that produces the best result.
Since the ultimate goal of an audio pitch corrector is to produce better sounding
music, the most rigorous way to judge the effectiveness of the pitch corrector
would be to run a psychological survey on which combination of sub modules sound
best. This is beyond the scope of this project. Instead, some simplifications are
made and metrics are designed based on the research done on music theory. These
metrics act as a proxy for the results given by a physiological survey and are
much easier and cheaper to run. Two aspects of the pitch corrector are chosen to
be assessed. The effectiveness of it and the noise or distortion of the audio
signal introduced by the pitch corrector.

The effectiveness metric is a way of measuring how much the pitch corrector
corrects the pitch. This metric will answer the question of how in tune the audio
is before and after the correction is applied and produce a number indicating the
improvement. The algorithm to achieve this will make use of the frequency contour
function. This this is a function of  the fundamental frequency of a signal over
time. From this frequency contour function, it is possible to find the closest
correct frequency to this function. The exact details of how the correct
frequencies are calculated will be explained in the ``Choosing Wanted Frequency''
section.

Here I reference the listing \ref{lst:getClosestFreqContour}.

\octavelisting{getClosestFreqContour}

\color{red}
To Do:
\begin{itemize}
	\item Describe effectiveness metric further
\end{itemize}
\color{black}

The effectiveness metric unfortunately relies on the frequency detector to be
absolutely correct. This is because it depends on the results of the frequency
contour before the correction was mad and after the correction was made. Therefore
a separate metric is designed to evaluate the frequency detector as an individual
module.  This is to provide some confidence that the frequency detector module
does provide a reasonably good approximation for the actual frequency contour.

\color{red}
To Do:
\begin{itemize}
	\item Describe Frequency Detection Metric
	\item Describe noise metric
	\item Describe why a frequency scaling metric is also needed
	\item Describe Frequency Scaling metric
	\item Summarise all the metrics (in a table?)
\end{itemize}
\color{black}

\section{Pitch Correction Design}

\color{red}
To do:
\begin{itemize}
	\item Touch on subsections and why each needs a section
\end{itemize}
\color{black}

\subsection{Structure}

\color{red}
To do:
\begin{itemize}
	\item Segmentation!!!
	\begin{itemize}
		\item Describe what segmentation is and why it is necessary
		\item Describe stages
		\begin{itemize}
			\item Split (overlap)
			\item Do computation
			\item Stitch (overlap and add)
		\end{itemize}
		\item Reason to overlap and size of overlapping (TRADE-OFF)
		\item Window size (TRADE-OFF)
		\begin{itemize}
			\item Small means low resolution
			\item Large means latency
			\item Small generally means more computation
		\end{itemize}
		\item Properties to preserve relevant to real time auto tuning
	\end{itemize}
	\item Flow diagram
	\item Actual code snips from Octave source code
\end{itemize}
\color{black}

\subsection{Interface}

\color{red}
To do:
\begin{itemize}
	\item Interface philosophy
	\item Frequency detectors and scalers should be swappable
\end{itemize}
\color{black}

\section{Choosing Wanted Frequency}

\color{red}
To do:
\begin{itemize}
	\item Describe why choosing wanted frequency is not trivial
	\item Naive approach
	\begin{itemize}
		\item Describe approach
		\item Show results of approach
	\end{itemize}
	\item Schmitt Trigger Approach
	\begin{itemize}
		\item Describe approach
		\item Show results of approach
	\end{itemize}
	\item Evaluation Metric
	\begin{itemize}
		\item Describe metric
		\item Show why Schmitt trigger is better
	\end{itemize}
\end{itemize}
\color{black}

\section{Frequency Detector}

\color{red}
To do:
\begin{itemize}
	\item Explain that this is the basis for the frequency scaler
	\item Explain other things
\end{itemize}
\color{black}

\subsection{Zero Crossing Method}

\color{red}
To do:
\begin{itemize}
	\item Describe method in more detail than lit review
	\item Show snips of code and graphically what it's doing
	\item Show performance metrics
\end{itemize}
\color{black}

\subsection{Autocorrelation Method}

\color{red}
To do:
\begin{itemize}
	\item Describe method in more detail than lit review
	\item Show snips of code and graphically what it's doing
	\item Show performance metrics
\end{itemize}
\color{black}

\section{Frequency Scaler}

\color{red}
To do:
\begin{itemize}
	\item Explain time vs frequency approaches
	\item Explain other things
\end{itemize}
\color{black}

\subsection{Phase Vocoder}

\color{red}
To do:
\begin{itemize}
	\item Describe method in more detail than lit review
	\item Show snips of code and graphically what it's doing
	\item Show performance metrics
\end{itemize}
\color{black}

\subsection{Simple Overlap and Add}

\color{red}
To do:
\begin{itemize}
	\item Describe method in more detail than lit review
	\item Show snips of code and graphically what it's doing
	\item Show performance metrics
\end{itemize}
\color{black}

\section{Pitch Corrector}

\color{red}
To do:
\begin{itemize}
	\item Describe which modules were added put together
	\item Describe why each module was chosen
	\item Describe each system and show its performance
\end{itemize}
\color{black}

\section{Concept Expansion}

\color{red}
To do:
\begin{itemize}
	\item Explain that more cool stuff were found
	\item Post Correction
	\item Harmonization
	\item Pitch Scaling by a Constant Factor
\end{itemize}
\color{black}
